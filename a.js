// @flow strict
//NOTE: This file is autogenerated. Do not modify.
//See packages/babel-types/scripts/generators/typescript.js for script used.

export type BaseComment = {
  value: string,
  start: number,
  end: number,
  loc: SourceLocation,
  type: "CommentBlock" | "CommentLine",
};

export type CommentBlock = { ...BaseComment, type: "CommentBlock" };

export type CommentLine = { ...BaseComment, type: "CommentLine" };

export type Comment = CommentBlock | CommentLine;

export type SourceLocation = {
  start: {
    line: number,
    column: number,
  },

  end: {
    line: number,
    column: number,
  },
};

export type BaseNode = {
  // leadingComments: ReadonlyArray<Comment> | null;
  // innerComments: ReadonlyArray<Comment> | null;
  // trailingComments: ReadonlyArray<Comment> | null;
  // start: number | null;
  // end: number | null;
  // loc: SourceLocation | null;
  +type: string,
  +extra?: [string, mixed],
};

export type Node =
  | AnyTypeAnnotation
  | ArgumentPlaceholder
  | ArrayExpression
  | ArrayPattern
  | ArrayTypeAnnotation
  | ArrowFunctionExpression
  | AssignmentExpression
  | AssignmentPattern
  | AwaitExpression
  | BigIntLiteral
  | Binary
  | BinaryExpression
  | BindExpression
  | Block
  | BlockParent
  | BlockStatement
  | BooleanLiteral
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | BreakStatement
  | CallExpression
  | CatchClause
  | Klass
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ClassImplements
  | ClassMethod
  | ClassPrivateMethod
  | ClassPrivateProperty
  | ClassProperty
  | CompletionStatement
  | Conditional
  | ConditionalExpression
  | ContinueStatement
  | DebuggerStatement
  | DecimalLiteral
  | Declaration
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | DeclaredPredicate
  | Decorator
  | Directive
  | DirectiveLiteral
  | DoExpression
  | DoWhileStatement
  | EmptyStatement
  | EmptyTypeAnnotation
  | EnumBody
  | EnumBooleanBody
  | EnumBooleanMember
  | EnumDeclaration
  | EnumDefaultedMember
  | EnumMember
  | EnumNumberBody
  | EnumNumberMember
  | EnumStringBody
  | EnumStringMember
  | EnumSymbolBody
  | ExistsTypeAnnotation
  | ExportAllDeclaration
  | ExportDeclaration
  | ExportDefaultDeclaration
  | ExportDefaultSpecifier
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | Expression
  | ExpressionStatement
  | ExpressionWrapper
  | File
  | Flow
  | FlowBaseAnnotation
  | FlowDeclaration
  | FlowPredicate
  | FlowType
  | For
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | ForXStatement
  | Fun
  | FunctionDeclaration
  | FunctionExpression
  | FunctionParent
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | Identifier
  | IfStatement
  | Immutable
  | Import
  | ImportAttribute
  | ImportDeclaration
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
  | InferredPredicate
  | InterfaceDeclaration
  | InterfaceExtends
  | InterfaceTypeAnnotation
  | InterpreterDirective
  | IntersectionTypeAnnotation
  | JSX
  | JSXAttribute
  | JSXClosingElement
  | JSXClosingFragment
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXFragment
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXText
  | LVal
  | LabeledStatement
  | Literal
  | LogicalExpression
  | Loop
  | MemberExpression
  | MetaProperty
  | Method
  | MixedTypeAnnotation
  | ModuleDeclaration
  | ModuleSpecifier
  | NewExpression
  | Noop
  | NullLiteral
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteral
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | NumericLiteral
  | ObjectExpression
  | ObjectMember
  | ObjectMethod
  | ObjectPattern
  | ObjectProperty
  | ObjectTypeAnnotation
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeInternalSlot
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | OpaqueType
  | OptionalCallExpression
  | OptionalMemberExpression
  | ParenthesizedExpression
  | Pattern
  | PatternLike
  | PipelineBareFunction
  | PipelinePrimaryTopicReference
  | PipelineTopicExpression
  | Placeholder
  | Private
  | PrivateName
  | Program
  | Property
  | Pureish
  | QualifiedTypeIdentifier
  | RecordExpression
  | RegExpLiteral
  | RegexLiteral
  | RestElement
  | RestProperty
  | ReturnStatement
  | Scopable
  | SequenceExpression
  | SpreadElement
  | SpreadProperty
  | Statement
  | StaticBlock
  | StringLiteral
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | Super
  | SwitchCase
  | SwitchStatement
  | SymbolTypeAnnotation
  | TSAnyKeyword
  | TSArrayType
  | TSAsExpression
  | TSBaseType
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSCallSignatureDeclaration
  | TSConditionalType
  | TSConstructSignatureDeclaration
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSEntityName
  | TSEnumDeclaration
  | TSEnumMember
  | TSExportAssignment
  | TSExpressionWithTypeArguments
  | TSExternalModuleReference
  | TSFunctionType
  | TSImportEqualsDeclaration
  | TSImportType
  | TSIndexSignature
  | TSIndexedAccessType
  | TSInferType
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSIntersectionType
  | TSIntrinsicKeyword
  | TSLiteralType
  | TSMappedType
  | TSMethodSignature
  | TSModuleBlock
  | TSModuleDeclaration
  | TSNamedTupleMember
  | TSNamespaceExportDeclaration
  | TSNeverKeyword
  | TSNonNullExpression
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSOptionalType
  | TSParameterProperty
  | TSParenthesizedType
  | TSPropertySignature
  | TSQualifiedName
  | TSRestType
  | TSStringKeyword
  | TSSymbolKeyword
  | TSThisType
  | TSTupleType
  | TSType
  | TSTypeAliasDeclaration
  | TSTypeAnnotation
  | TSTypeAssertion
  | TSTypeElement
  | TSTypeLiteral
  | TSTypeOperator
  | TSTypeParameter
  | TSTypeParameterDeclaration
  | TSTypeParameterInstantiation
  | TSTypePredicate
  | TSTypeQuery
  | TSTypeReference
  | TSUndefinedKeyword
  | TSUnionType
  | TSUnknownKeyword
  | TSVoidKeyword
  | TaggedTemplateExpression
  | TemplateElement
  | TemplateLiteral
  | Terminatorless
  | ThisExpression
  | ThisTypeAnnotation
  | ThrowStatement
  | TryStatement
  | TupleExpression
  | TupleTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypeofTypeAnnotation
  | UnaryExpression
  | UnaryLike
  | UnionTypeAnnotation
  | UpdateExpression
  | UserWhitespacable
  | V8IntrinsicIdentifier
  | VariableDeclaration
  | VariableDeclarator
  | Variance
  | VoidTypeAnnotation
  | While
  | WhileStatement
  | WithStatement
  | YieldExpression;

export type ArrayExpression = {
  ...BaseNode,
  type: "ArrayExpression",
  elements: Array<null | Expression | SpreadElement>,
};

export type AssignmentExpression = {
  ...BaseNode,
  type: "AssignmentExpression",
  operator: string,
  left: LVal,
  right: Expression,
};

export type BinaryExpression = {
  ...BaseNode,
  type: "BinaryExpression",
  operator:
    | "+"
    | "-"
    | "/"
    | "%"
    | "*"
    | "**"
    | "&"
    | "|"
    | ">>"
    | ">>>"
    | "<<"
    | "^"
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
    | ">"
    | "<"
    | ">="
    | "<=",
  left: Expression | PrivateName,
  right: Expression,
};

export type InterpreterDirective = {
  ...BaseNode,
  type: "InterpreterDirective",
  value: string,
};

export type Directive = { ...BaseNode, type: "Directive", value: DirectiveLiteral };

export type DirectiveLiteral = {
  ...BaseNode,
  type: "DirectiveLiteral",
  value: string,
};

export type BlockStatement = {
  ...BaseNode,
  type: "BlockStatement",
  body: Array<Statement>,
  directives: Array<Directive>,
};

export type BreakStatement = {
  ...BaseNode,
  type: "BreakStatement",
  label: Identifier | null,
};

export type CallExpression = {
  ...BaseNode,
  type: "CallExpression",
  callee: Expression | V8IntrinsicIdentifier,
  arguments: Array<
    Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder
  >,
  optional: true | false | null,
  typeArguments: TypeParameterInstantiation | null,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type CatchClause = {
  ...BaseNode,
  type: "CatchClause",
  param: Identifier | ArrayPattern | ObjectPattern | null,
  body: BlockStatement,
};

export type ConditionalExpression = {
  ...BaseNode,
  type: "ConditionalExpression",
  test: Expression,
  consequent: Expression,
  alternate: Expression,
};

export type ContinueStatement = {
  ...BaseNode,
  type: "ContinueStatement",
  label: Identifier | null,
};

export type DebuggerStatement = { ...BaseNode, type: "DebuggerStatement" };

export type DoWhileStatement = {
  ...BaseNode,
  type: "DoWhileStatement",
  test: Expression,
  body: Statement,
};

export type EmptyStatement = { ...BaseNode, type: "EmptyStatement" };

export type ExpressionStatement = {
  ...BaseNode,
  type: "ExpressionStatement",
  expression: Expression,
};

export type File = {
  ...BaseNode,
  type: "File",
  program: Program,
  comments: Array<CommentBlock | CommentLine> | null,
  tokens: Array<mixed> | null,
};

export type ForInStatement = {
  ...BaseNode,
  type: "ForInStatement",
  left: VariableDeclaration | LVal,
  right: Expression,
  body: Statement,
};

export type ForStatement = {
  ...BaseNode,
  type: "ForStatement",
  init: VariableDeclaration | Expression | null,
  test: Expression | null,
  update: Expression | null,
  body: Statement,
};

export type FunctionDeclaration = {
  ...BaseNode,
  type: "FunctionDeclaration",
  id: Identifier | null,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement,
  generator: boolean,
  async: boolean,
  declare: boolean | null,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type FunctionExpression = {
  ...BaseNode,
  type: "FunctionExpression",
  id: Identifier | null,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement,
  generator: boolean,
  async: boolean,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type Identifier = {
  ...BaseNode,
  type: "Identifier",
  name: string,
  decorators: Array<Decorator> | null,
  optional: boolean | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
};

export type IfStatement = {
  ...BaseNode,
  type: "IfStatement",
  test: Expression,
  consequent: Statement,
  alternate: Statement | null,
};

export type LabeledStatement = {
  ...BaseNode,
  type: "LabeledStatement",
  label: Identifier,
  body: Statement,
};

export type StringLiteral = { ...BaseNode, type: "StringLiteral", value: string };

export type NumericLiteral = { ...BaseNode, type: "NumericLiteral", value: number };

export type NullLiteral = { ...BaseNode, type: "NullLiteral" };

export type BooleanLiteral = {
  ...BaseNode,
  type: "BooleanLiteral",
  value: boolean,
};

export type RegExpLiteral = {
  ...BaseNode,
  type: "RegExpLiteral",
  pattern: string,
  flags: string,
};

export type LogicalExpression = {
  ...BaseNode,
  type: "LogicalExpression",
  operator: "||" | "&&" | "??",
  left: Expression,
  right: Expression,
};

export type MemberExpression = {
  ...BaseNode,
  type: "MemberExpression",
  object: Expression,
  property: Expression | Identifier | PrivateName,
  computed: boolean,
  optional: true | false | null,
};

export type NewExpression = {
  ...BaseNode,
  type: "NewExpression",
  callee: Expression | V8IntrinsicIdentifier,
  arguments: Array<
    Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder
  >,
  optional: true | false | null,
  typeArguments: TypeParameterInstantiation | null,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type Program = {
  ...BaseNode,
  type: "Program",
  body: Array<Statement>,
  directives: Array<Directive>,
  sourceType: "script" | "module",
  interpreter: InterpreterDirective | null,
  sourceFile: string,
};

export type ObjectExpression = {
  ...BaseNode,
  type: "ObjectExpression",
  properties: Array<ObjectMethod | ObjectProperty | SpreadElement>,
};

export type ObjectMethod = {
  ...BaseNode,
  type: "ObjectMethod",
  kind: "method" | "get" | "set",
  key: Expression | Identifier | StringLiteral | NumericLiteral,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement,
  computed: boolean,
  generator: boolean,
  async: boolean,
  decorators: Array<Decorator> | null,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ObjectProperty = {
  ...BaseNode,
  type: "ObjectProperty",
  key: Expression | Identifier | StringLiteral | NumericLiteral,
  value: Expression | PatternLike,
  computed: boolean,
  shorthand: boolean,
  decorators: Array<Decorator> | null,
};

export type RestElement = {
  ...BaseNode,
  type: "RestElement",
  argument: LVal,
  decorators: Array<Decorator> | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
};

export type ReturnStatement = {
  ...BaseNode,
  type: "ReturnStatement",
  argument: Expression | null,
};

export type SequenceExpression = {
  ...BaseNode,
  type: "SequenceExpression",
  expressions: Array<Expression>,
};

export type ParenthesizedExpression = {
  ...BaseNode,
  type: "ParenthesizedExpression",
  expression: Expression,
};

export type SwitchCase = {
  ...BaseNode,
  type: "SwitchCase",
  test: Expression | null,
  consequent: Array<Statement>,
};

export type SwitchStatement = {
  ...BaseNode,
  type: "SwitchStatement",
  discriminant: Expression,
  cases: Array<SwitchCase>,
};

export type ThisExpression = { ...BaseNode, type: "ThisExpression" };

export type ThrowStatement = {
  ...BaseNode,
  type: "ThrowStatement",
  argument: Expression,
};

export type TryStatement = {
  ...BaseNode,
  type: "TryStatement",
  block: BlockStatement,
  handler: CatchClause | null,
  finalizer: BlockStatement | null,
};

export type UnaryExpression = {
  ...BaseNode,
  type: "UnaryExpression",
  operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof",
  argument: Expression,
  prefix: boolean,
};

export type UpdateExpression = {
  ...BaseNode,
  type: "UpdateExpression",
  operator: "++" | "--",
  argument: Expression,
  prefix: boolean,
};

export type VariableDeclaration = {
  ...BaseNode,
  type: "VariableDeclaration",
  kind: "var" | "let" | "const",
  declarations: Array<VariableDeclarator>,
  declare: boolean | null,
};

export type VariableDeclarator = {
  ...BaseNode,
  type: "VariableDeclarator",
  id: LVal,
  init: Expression | null,
  definite: boolean | null,
};

export type WhileStatement = {
  ...BaseNode,
  type: "WhileStatement",
  test: Expression,
  body: Statement,
};

export type WithStatement = {
  ...BaseNode,
  type: "WithStatement",
  object: Expression,
  body: Statement,
};

export type AssignmentPattern = {
  ...BaseNode,
  type: "AssignmentPattern",
  left: Identifier | ObjectPattern | ArrayPattern | MemberExpression,
  right: Expression,
  decorators: Array<Decorator> | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
};

export type ArrayPattern = {
  ...BaseNode,
  type: "ArrayPattern",
  elements: Array<null | PatternLike>,
  decorators: Array<Decorator> | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
};

export type ArrowFunctionExpression = {
  ...BaseNode,
  type: "ArrowFunctionExpression",
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement | Expression,
  async: boolean,
  expression: boolean,
  generator: boolean,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ClassBody = {
  ...BaseNode,
  type: "ClassBody",
  body: Array<
    | ClassMethod
    | ClassPrivateMethod
    | ClassProperty
    | ClassPrivateProperty
    | TSDeclareMethod
    | TSIndexSignature
  >,
};

export type ClassExpression = {
  ...BaseNode,
  type: "ClassExpression",
  id: Identifier | null,
  superClass: Expression | null,
  body: ClassBody,
  decorators: Array<Decorator> | null,
  implements: Array<TSExpressionWithTypeArguments | ClassImplements> | null,
  mixins: InterfaceExtends | null,
  superTypeParameters:
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ClassDeclaration = {
  ...BaseNode,
  type: "ClassDeclaration",
  id: Identifier,
  superClass: Expression | null,
  body: ClassBody,
  decorators: Array<Decorator> | null,
  abstract: boolean | null,
  declare: boolean | null,
  implements: Array<TSExpressionWithTypeArguments | ClassImplements> | null,
  mixins: InterfaceExtends | null,
  superTypeParameters:
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ExportAllDeclaration = {
  ...BaseNode,
  type: "ExportAllDeclaration",
  source: StringLiteral,
};

export type ExportDefaultDeclaration = {
  ...BaseNode,
  type: "ExportDefaultDeclaration",
  declaration:
    | FunctionDeclaration
    | TSDeclareFunction
    | ClassDeclaration
    | Expression,
};

export type ExportNamedDeclaration = {
  ...BaseNode,
  type: "ExportNamedDeclaration",
  declaration: Declaration | null,
  specifiers: Array<
    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier
  >,
  source: StringLiteral | null,
  exportKind: "type" | "value" | null,
};

export type ExportSpecifier = {
  ...BaseNode,
  type: "ExportSpecifier",
  local: Identifier,
  exported: Identifier | StringLiteral,
};

export type ForOfStatement = {
  ...BaseNode,
  type: "ForOfStatement",
  left: VariableDeclaration | LVal,
  right: Expression,
  body: Statement,
  await: boolean,
};

export type ImportDeclaration = {
  ...BaseNode,
  type: "ImportDeclaration",
  specifiers: Array<
    ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier
  >,
  source: StringLiteral,
  importKind: "type" | "typeof" | "value" | null,
};

export type ImportDefaultSpecifier = {
  ...BaseNode,
  type: "ImportDefaultSpecifier",
  local: Identifier,
};

export type ImportNamespaceSpecifier = {
  ...BaseNode,
  type: "ImportNamespaceSpecifier",
  local: Identifier,
};

export type ImportSpecifier = {
  ...BaseNode,
  type: "ImportSpecifier",
  local: Identifier,
  imported: Identifier | StringLiteral,
  importKind: "type" | "typeof" | null,
};

export type MetaProperty = {
  ...BaseNode,
  type: "MetaProperty",
  meta: Identifier,
  property: Identifier,
};

export type ClassMethod = {
  ...BaseNode,
  type: "ClassMethod",
  kind: "get" | "set" | "method" | "constructor",
  key: Identifier | StringLiteral | NumericLiteral | Expression,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement,
  computed: boolean,
  static: boolean,
  generator: boolean,
  async: boolean,
  abstract: boolean | null,
  access: "public" | "private" | "protected" | null,
  accessibility: "public" | "private" | "protected" | null,
  decorators: Array<Decorator> | null,
  optional: boolean | null,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ObjectPattern = {
  ...BaseNode,
  type: "ObjectPattern",
  properties: Array<RestElement | ObjectProperty>,
  decorators: Array<Decorator> | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
};

export type SpreadElement = {
  ...BaseNode,
  type: "SpreadElement",
  argument: Expression,
};

export type Super = { ...BaseNode, type: "Super" };

export type TaggedTemplateExpression = {
  ...BaseNode,
  type: "TaggedTemplateExpression",
  tag: Expression,
  quasi: TemplateLiteral,
  typeParameters:
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | null,
};

export type TemplateElement = {
  ...BaseNode,
  type: "TemplateElement",
  value: { raw: string, cooked?: string },
  tail: boolean,
};

export type TemplateLiteral = {
  ...BaseNode,
  type: "TemplateLiteral",
  quasis: Array<TemplateElement>,
  expressions: Array<Expression | TSType>,
};

export type YieldExpression = {
  ...BaseNode,
  type: "YieldExpression",
  argument: Expression | null,
  delegate: boolean,
};

export type AwaitExpression = {
  ...BaseNode,
  type: "AwaitExpression",
  argument: Expression,
};

export type Import = { ...BaseNode, type: "Import" };

export type BigIntLiteral = { ...BaseNode, type: "BigIntLiteral", value: string };

export type ExportNamespaceSpecifier = {
  ...BaseNode,
  type: "ExportNamespaceSpecifier",
  exported: Identifier,
};

export type OptionalMemberExpression = {
  ...BaseNode,
  type: "OptionalMemberExpression",
  object: Expression,
  property: Expression | Identifier,
  computed: boolean,
  optional: boolean,
};

export type OptionalCallExpression = {
  ...BaseNode,
  type: "OptionalCallExpression",
  callee: Expression,
  arguments: Array<Expression | SpreadElement | JSXNamespacedName>,
  optional: boolean,
  typeArguments: TypeParameterInstantiation | null,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type AnyTypeAnnotation = { ...BaseNode, type: "AnyTypeAnnotation" };

export type ArrayTypeAnnotation = {
  ...BaseNode,
  type: "ArrayTypeAnnotation",
  elementType: FlowType,
};

export type BooleanTypeAnnotation = { ...BaseNode, type: "BooleanTypeAnnotation" };

export type BooleanLiteralTypeAnnotation = {
  ...BaseNode,
  type: "BooleanLiteralTypeAnnotation",
  value: boolean,
};

export type NullLiteralTypeAnnotation = {
  ...BaseNode,
  type: "NullLiteralTypeAnnotation",
};

export type ClassImplements = {
  ...BaseNode,
  type: "ClassImplements",
  id: Identifier,
  typeParameters: TypeParameterInstantiation | null,
};

export type DeclareClass = {
  ...BaseNode,
  type: "DeclareClass",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  extends: Array<InterfaceExtends> | null,
  body: ObjectTypeAnnotation,
  implements: Array<ClassImplements> | null,
  mixins: Array<InterfaceExtends> | null,
};

export type DeclareFunction = {
  ...BaseNode,
  type: "DeclareFunction",
  id: Identifier,
  predicate: DeclaredPredicate | null,
};

export type DeclareInterface = {
  ...BaseNode,
  type: "DeclareInterface",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  extends: Array<InterfaceExtends> | null,
  body: ObjectTypeAnnotation,
  implements: Array<ClassImplements> | null,
  mixins: Array<InterfaceExtends> | null,
};

export type DeclareModule = {
  ...BaseNode,
  type: "DeclareModule",
  id: Identifier | StringLiteral,
  body: BlockStatement,
  kind: "CommonJS" | "ES" | null,
};

export type DeclareModuleExports = {
  ...BaseNode,
  type: "DeclareModuleExports",
  typeAnnotation: TypeAnnotation,
};

export type DeclareTypeAlias = {
  ...BaseNode,
  type: "DeclareTypeAlias",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  right: FlowType,
};

export type DeclareOpaqueType = {
  ...BaseNode,
  type: "DeclareOpaqueType",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  supertype: FlowType | null,
};

export type DeclareVariable = {
  ...BaseNode,
  type: "DeclareVariable",
  id: Identifier,
};

export type DeclareExportDeclaration = {
  ...BaseNode,
  type: "DeclareExportDeclaration",
  declaration: Flow | null,
  specifiers: Array<ExportSpecifier | ExportNamespaceSpecifier> | null,
  source: StringLiteral | null,
  default: boolean | null,
};

export type DeclareExportAllDeclaration = {
  ...BaseNode,
  type: "DeclareExportAllDeclaration",
  source: StringLiteral,
  exportKind: "type" | "value" | null,
};

export type DeclaredPredicate = {
  ...BaseNode,
  type: "DeclaredPredicate",
  value: Flow,
};

export type ExistsTypeAnnotation = { ...BaseNode, type: "ExistsTypeAnnotation" };

export type FunctionTypeAnnotation = {
  ...BaseNode,
  type: "FunctionTypeAnnotation",
  typeParameters: TypeParameterDeclaration | null,
  params: Array<FunctionTypeParam>,
  rest: FunctionTypeParam | null,
  returnType: FlowType,
};

export type FunctionTypeParam = {
  ...BaseNode,
  type: "FunctionTypeParam",
  name: Identifier | null,
  typeAnnotation: FlowType,
  optional: boolean | null,
};

export type GenericTypeAnnotation = {
  ...BaseNode,
  type: "GenericTypeAnnotation",
  id: Identifier | QualifiedTypeIdentifier,
  typeParameters: TypeParameterInstantiation | null,
};

export type InferredPredicate = { ...BaseNode, type: "InferredPredicate" };

export type InterfaceExtends = {
  ...BaseNode,
  type: "InterfaceExtends",
  id: Identifier | QualifiedTypeIdentifier,
  typeParameters: TypeParameterInstantiation | null,
};

export type InterfaceDeclaration = {
  ...BaseNode,
  type: "InterfaceDeclaration",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  extends: Array<InterfaceExtends> | null,
  body: ObjectTypeAnnotation,
  implements: Array<ClassImplements> | null,
  mixins: Array<InterfaceExtends> | null,
};

export type InterfaceTypeAnnotation = {
  ...BaseNode,
  type: "InterfaceTypeAnnotation",
  extends: Array<InterfaceExtends> | null,
  body: ObjectTypeAnnotation,
};

export type IntersectionTypeAnnotation = {
  ...BaseNode,
  type: "IntersectionTypeAnnotation",
  types: Array<FlowType>,
};

export type MixedTypeAnnotation = { ...BaseNode, type: "MixedTypeAnnotation" };

export type EmptyTypeAnnotation = { ...BaseNode, type: "EmptyTypeAnnotation" };

export type NullableTypeAnnotation = {
  ...BaseNode,
  type: "NullableTypeAnnotation",
  typeAnnotation: FlowType,
};

export type NumberLiteralTypeAnnotation = {
  ...BaseNode,
  type: "NumberLiteralTypeAnnotation",
  value: number,
};

export type NumberTypeAnnotation = { ...BaseNode, type: "NumberTypeAnnotation" };

export type ObjectTypeAnnotation = {
  ...BaseNode,
  type: "ObjectTypeAnnotation",
  properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>,
  indexers: Array<ObjectTypeIndexer> | null,
  callProperties: Array<ObjectTypeCallProperty> | null,
  internalSlots: Array<ObjectTypeInternalSlot> | null,
  exact: boolean,
  inexact: boolean | null,
};

export type ObjectTypeInternalSlot = {
  ...BaseNode,
  type: "ObjectTypeInternalSlot",
  id: Identifier,
  value: FlowType,
  optional: boolean,
  static: boolean,
  method: boolean,
};

export type ObjectTypeCallProperty = {
  ...BaseNode,
  type: "ObjectTypeCallProperty",
  value: FlowType,
  static: boolean,
};

export type ObjectTypeIndexer = {
  ...BaseNode,
  type: "ObjectTypeIndexer",
  id: Identifier | null,
  key: FlowType,
  value: FlowType,
  variance: Variance | null,
  static: boolean,
};

export type ObjectTypeProperty = {
  ...BaseNode,
  type: "ObjectTypeProperty",
  key: Identifier | StringLiteral,
  value: FlowType,
  variance: Variance | null,
  kind: "init" | "get" | "set",
  optional: boolean,
  proto: boolean,
  static: boolean,
};

export type ObjectTypeSpreadProperty = {
  ...BaseNode,
  type: "ObjectTypeSpreadProperty",
  argument: FlowType,
};

export type OpaqueType = {
  ...BaseNode,
  type: "OpaqueType",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  supertype: FlowType | null,
  impltype: FlowType,
};

export type QualifiedTypeIdentifier = {
  ...BaseNode,
  type: "QualifiedTypeIdentifier",
  id: Identifier,
  qualification: Identifier | QualifiedTypeIdentifier,
};

export type StringLiteralTypeAnnotation = {
  ...BaseNode,
  type: "StringLiteralTypeAnnotation",
  value: string,
};

export type StringTypeAnnotation = { ...BaseNode, type: "StringTypeAnnotation" };

export type SymbolTypeAnnotation = { ...BaseNode, type: "SymbolTypeAnnotation" };

export type ThisTypeAnnotation = { ...BaseNode, type: "ThisTypeAnnotation" };

export type TupleTypeAnnotation = {
  ...BaseNode,
  type: "TupleTypeAnnotation",
  types: Array<FlowType>,
};

export type TypeofTypeAnnotation = {
  ...BaseNode,
  type: "TypeofTypeAnnotation",
  argument: FlowType,
};

export type TypeAlias = {
  ...BaseNode,
  type: "TypeAlias",
  id: Identifier,
  typeParameters: TypeParameterDeclaration | null,
  right: FlowType,
};

export type TypeAnnotation = {
  ...BaseNode,
  type: "TypeAnnotation",
  typeAnnotation: FlowType,
};

export type TypeCastExpression = {
  ...BaseNode,
  type: "TypeCastExpression",
  expression: Expression,
  typeAnnotation: TypeAnnotation,
};

export type TypeParameter = {
  ...BaseNode,
  type: "TypeParameter",
  bound: TypeAnnotation | null,
  default: FlowType | null,
  variance: Variance | null,
  name: string,
};

export type TypeParameterDeclaration = {
  ...BaseNode,
  type: "TypeParameterDeclaration",
  params: Array<TypeParameter>,
};

export type TypeParameterInstantiation = {
  ...BaseNode,
  type: "TypeParameterInstantiation",
  params: Array<FlowType>,
};

export type UnionTypeAnnotation = {
  ...BaseNode,
  type: "UnionTypeAnnotation",
  types: Array<FlowType>,
};

export type Variance = { ...BaseNode, type: "Variance", kind: "minus" | "plus" };

export type VoidTypeAnnotation = { ...BaseNode, type: "VoidTypeAnnotation" };

export type EnumDeclaration = {
  ...BaseNode,
  type: "EnumDeclaration",
  id: Identifier,
  body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody,
};

export type EnumBooleanBody = {
  ...BaseNode,
  type: "EnumBooleanBody",
  members: Array<EnumBooleanMember>,
  explicit: boolean,
};

export type EnumNumberBody = {
  ...BaseNode,
  type: "EnumNumberBody",
  members: Array<EnumNumberMember>,
  explicit: boolean,
};

export type EnumStringBody = {
  ...BaseNode,
  type: "EnumStringBody",
  members: Array<EnumStringMember | EnumDefaultedMember>,
  explicit: boolean,
};

export type EnumSymbolBody = {
  ...BaseNode,
  type: "EnumSymbolBody",
  members: Array<EnumDefaultedMember>,
};

export type EnumBooleanMember = {
  ...BaseNode,
  type: "EnumBooleanMember",
  id: Identifier,
  init: BooleanLiteral,
};

export type EnumNumberMember = {
  ...BaseNode,
  type: "EnumNumberMember",
  id: Identifier,
  init: NumericLiteral,
};

export type EnumStringMember = {
  ...BaseNode,
  type: "EnumStringMember",
  id: Identifier,
  init: StringLiteral,
};

export type EnumDefaultedMember = {
  ...BaseNode,
  type: "EnumDefaultedMember",
  id: Identifier,
};

export type JSXAttribute = {
  ...BaseNode,
  type: "JSXAttribute",
  name: JSXIdentifier | JSXNamespacedName,
  value:
    | JSXElement
    | JSXFragment
    | StringLiteral
    | JSXExpressionContainer
    | null,
};

export type JSXClosingElement = {
  ...BaseNode,
  type: "JSXClosingElement",
  name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
};

export type JSXElement = {
  ...BaseNode,
  type: "JSXElement",
  openingElement: JSXOpeningElement,
  closingElement: JSXClosingElement | null,
  children: Array<
    JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment
  >,
  selfClosing: boolean | null,
};

export type JSXEmptyExpression = { ...BaseNode, type: "JSXEmptyExpression" };

export type JSXExpressionContainer = {
  ...BaseNode,
  type: "JSXExpressionContainer",
  expression: Expression | JSXEmptyExpression,
};

export type JSXSpreadChild = {
  ...BaseNode,
  type: "JSXSpreadChild",
  expression: Expression,
};

export type JSXIdentifier = { ...BaseNode, type: "JSXIdentifier", name: string };

export type JSXMemberExpression = {
  ...BaseNode,
  type: "JSXMemberExpression",
  object: JSXMemberExpression | JSXIdentifier,
  property: JSXIdentifier,
};

export type JSXNamespacedName = {
  ...BaseNode,
  type: "JSXNamespacedName",
  namespace: JSXIdentifier,
  name: JSXIdentifier,
};

export type JSXOpeningElement = {
  ...BaseNode,
  type: "JSXOpeningElement",
  name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
  attributes: Array<JSXAttribute | JSXSpreadAttribute>,
  selfClosing: boolean,
  typeParameters:
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | null,
};

export type JSXSpreadAttribute = {
  ...BaseNode,
  type: "JSXSpreadAttribute",
  argument: Expression,
};

export type JSXText = { ...BaseNode, type: "JSXText", value: string };

export type JSXFragment = {
  ...BaseNode,
  type: "JSXFragment",
  openingFragment: JSXOpeningFragment,
  closingFragment: JSXClosingFragment,
  children: Array<
    JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment
  >,
};

export type JSXOpeningFragment = { ...BaseNode, type: "JSXOpeningFragment" };

export type JSXClosingFragment = { ...BaseNode, type: "JSXClosingFragment" };

export type Noop = { ...BaseNode, type: "Noop" };

export type Placeholder = {
  ...BaseNode,
  type: "Placeholder",
 expectedNode:  
    | "Identifier"
    | "StringLiteral"
    | "Expression"
    | "Statement"
    | "Declaration"
    | "BlockStatement"
    | "ClassBody"
    | "Pattern",
  name: Identifier,
};

export type V8IntrinsicIdentifier = {
  ...BaseNode,
  type: "V8IntrinsicIdentifier",
  name: string,
};

export type ArgumentPlaceholder = { ...BaseNode, type: "ArgumentPlaceholder" };

export type BindExpression = {
  ...BaseNode,
  type: "BindExpression",
  object: Expression,
  callee: Expression,
};

export type ClassProperty = {
  ...BaseNode,
  type: "ClassProperty",
  key: Identifier | StringLiteral | NumericLiteral | Expression,
  value: Expression | null,
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
  decorators: Array<Decorator> | null,
  computed: boolean,
  static: boolean,
  abstract: boolean | null,
  accessibility: "public" | "private" | "protected" | null,
  declare: boolean | null,
  definite: boolean | null,
  optional: boolean | null,
  readonly: boolean | null,
};

export type PipelineTopicExpression = {
  ...BaseNode,
  type: "PipelineTopicExpression",
  expression: Expression,
};

export type PipelineBareFunction = {
  ...BaseNode,
  type: "PipelineBareFunction",
  callee: Expression,
};

export type PipelinePrimaryTopicReference = {
  ...BaseNode,
  type: "PipelinePrimaryTopicReference",
};

export type ClassPrivateProperty = {
  ...BaseNode,
  type: "ClassPrivateProperty",
  key: PrivateName,
  value: Expression | null,
  decorators: Array<Decorator> | null,
  static: mixed,
};

export type ClassPrivateMethod = {
  ...BaseNode,
  type: "ClassPrivateMethod",
  kind: "get" | "set" | "method" | "constructor",
  key: PrivateName,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  body: BlockStatement,
  static: boolean,
  abstract: boolean | null,
  access: "public" | "private" | "protected" | null,
  accessibility: "public" | "private" | "protected" | null,
  async: boolean,
  computed: boolean,
  decorators: Array<Decorator> | null,
  generator: boolean,
  optional: boolean | null,
  returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
  typeParameters:
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | Noop
    | null,
};

export type ImportAttribute = {
  ...BaseNode,
  type: "ImportAttribute",
  key: Identifier | StringLiteral,
  value: StringLiteral,
};

export type Decorator = { ...BaseNode, type: "Decorator", expression: Expression };

export type DoExpression = {
  ...BaseNode,
  type: "DoExpression",
  body: BlockStatement,
};

export type ExportDefaultSpecifier = {
  ...BaseNode,
  type: "ExportDefaultSpecifier",
  exported: Identifier,
};

export type PrivateName = { ...BaseNode, type: "PrivateName", id: Identifier };

export type RecordExpression = {
  ...BaseNode,
  type: "RecordExpression",
  properties: Array<ObjectProperty | SpreadElement>,
};

export type TupleExpression = {
  ...BaseNode,
  type: "TupleExpression",
  elements: Array<Expression | SpreadElement>,
};

export type DecimalLiteral = { ...BaseNode, type: "DecimalLiteral", value: string };

export type StaticBlock = {
  ...BaseNode,
  type: "StaticBlock",
  body: Array<Statement>,
};

export type TSParameterProperty = {
  ...BaseNode,
  type: "TSParameterProperty",
  parameter: Identifier | AssignmentPattern,
  accessibility: "public" | "private" | "protected" | null,
  readonly: boolean | null,
};

export type TSDeclareFunction = {
  ...BaseNode,
  type: "TSDeclareFunction",
  id: Identifier | null,
  typeParameters: TSTypeParameterDeclaration | Noop | null,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  returnType: TSTypeAnnotation | Noop | null,
  async: boolean,
  declare: boolean | null,
  generator: boolean,
};

export type TSDeclareMethod = {
  ...BaseNode,
  type: "TSDeclareMethod",
  decorators: Array<Decorator> | null,
  key: Identifier | StringLiteral | NumericLiteral | Expression,
  typeParameters: TSTypeParameterDeclaration | Noop | null,
  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
  returnType: TSTypeAnnotation | Noop | null,
  abstract: boolean | null,
  access: "public" | "private" | "protected" | null,
  accessibility: "public" | "private" | "protected" | null,
  async: boolean,
  computed: boolean,
  generator: boolean,
  kind: "get" | "set" | "method" | "constructor",
  optional: boolean | null,
  static: boolean,
};

export type TSQualifiedName = {
  ...BaseNode,
  type: "TSQualifiedName",
  left: TSEntityName,
  right: Identifier,
};
export type TSCallSignatureDeclaration = {
  ...BaseNode,
  type: "TSCallSignatureDeclaration",
  typeParameters: TSTypeParameterDeclaration | null,
  parameters: Array<Identifier | RestElement>,
  typeAnnotation: TSTypeAnnotation | null,
};

export type TSConstructSignatureDeclaration = {
  ...BaseNode,
  type: "TSConstructSignatureDeclaration",
  typeParameters: TSTypeParameterDeclaration | null,
  parameters: Array<Identifier | RestElement>,
  typeAnnotation: TSTypeAnnotation | null,
};

export type TSPropertySignature = {
  ...BaseNode,
  type: "TSPropertySignature",
  key: Expression,
  typeAnnotation: TSTypeAnnotation | null,
  initializer: Expression | null,
  computed: boolean | null,
  optional: boolean | null,
  readonly: boolean | null,
};

export type TSMethodSignature = {
  ...BaseNode,
  type: "TSMethodSignature",
  key: Expression,
  typeParameters: TSTypeParameterDeclaration | null,
  parameters: Array<Identifier | RestElement>,
  typeAnnotation: TSTypeAnnotation | null,
  computed: boolean | null,
  optional: boolean | null,
};

export type TSIndexSignature = {
  ...BaseNode,
  type: "TSIndexSignature",
  parameters: Array<Identifier>,
  typeAnnotation: TSTypeAnnotation | null,
  readonly: boolean | null,
};

export type TSAnyKeyword = { ...BaseNode, type: "TSAnyKeyword" };

export type TSBooleanKeyword = { ...BaseNode, type: "TSBooleanKeyword" };

export type TSBigIntKeyword = { ...BaseNode, type: "TSBigIntKeyword" };

export type TSIntrinsicKeyword = { ...BaseNode, type: "TSIntrinsicKeyword" };

export type TSNeverKeyword = { ...BaseNode, type: "TSNeverKeyword" };

export type TSNullKeyword = { ...BaseNode, type: "TSNullKeyword" };

export type TSNumberKeyword = { ...BaseNode, type: "TSNumberKeyword" };

export type TSObjectKeyword = { ...BaseNode, type: "TSObjectKeyword" };

export type TSStringKeyword = { ...BaseNode, type: "TSStringKeyword" };

export type TSSymbolKeyword = { ...BaseNode, type: "TSSymbolKeyword" };

export type TSUndefinedKeyword = { ...BaseNode, type: "TSUndefinedKeyword" };

export type TSUnknownKeyword = { ...BaseNode, type: "TSUnknownKeyword" };

export type TSVoidKeyword = { ...BaseNode, type: "TSVoidKeyword" };

export type TSThisType = { ...BaseNode, type: "TSThisType" };

export type TSFunctionType = {
  ...BaseNode,
  type: "TSFunctionType",
  typeParameters: TSTypeParameterDeclaration | null,
  parameters: Array<Identifier | RestElement>,
  typeAnnotation: TSTypeAnnotation | null,
};

export type TSConstructorType = {
  ...BaseNode,
  type: "TSConstructorType",
  typeParameters: TSTypeParameterDeclaration | null,
  parameters: Array<Identifier | RestElement>,
  typeAnnotation: TSTypeAnnotation | null,
};

export type TSTypeReference = {
  ...BaseNode,
  type: "TSTypeReference",
  typeName: TSEntityName,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type TSTypePredicate = {
  ...BaseNode,
  type: "TSTypePredicate",
  parameterName: Identifier | TSThisType,
  typeAnnotation: TSTypeAnnotation | null,
  asserts: boolean | null,
};

export type TSTypeQuery = {
  ...BaseNode,
  type: "TSTypeQuery",
  exprName: TSEntityName | TSImportType,
};

export type TSTypeLiteral = {
  ...BaseNode,
  type: "TSTypeLiteral",
  members: Array<TSTypeElement>,
};

export type TSArrayType = { ...BaseNode, type: "TSArrayType", elementType: TSType };

export type TSTupleType = {
  ...BaseNode,
  type: "TSTupleType",
  elementTypes: Array<TSType | TSNamedTupleMember>,
};

export type TSOptionalType = {
  ...BaseNode,
  type: "TSOptionalType",
  typeAnnotation: TSType,
};

export type TSRestType = {
  ...BaseNode,
  type: "TSRestType",
  typeAnnotation: TSType,
};

export type TSNamedTupleMember = {
  ...BaseNode,
  type: "TSNamedTupleMember",
  label: Identifier,
  elementType: TSType,
  optional: boolean,
};

export type TSUnionType = {
  ...BaseNode,
  type: "TSUnionType",
  types: Array<TSType>,
};

export type TSIntersectionType = {
  ...BaseNode,
  type: "TSIntersectionType",
  types: Array<TSType>,
};

export type TSConditionalType = {
  ...BaseNode,
  type: "TSConditionalType",
  checkType: TSType,
  extendsType: TSType,
  trueType: TSType,
  falseType: TSType,
};

export type TSInferType = {
  ...BaseNode,
  type: "TSInferType",
  typeParameter: TSTypeParameter,
};

export type TSParenthesizedType = {
  ...BaseNode,
  type: "TSParenthesizedType",
  typeAnnotation: TSType,
};

export type TSTypeOperator = {
  ...BaseNode,
  type: "TSTypeOperator",
  typeAnnotation: TSType,
  operator: string,
};

export type TSIndexedAccessType = {
  ...BaseNode,
  type: "TSIndexedAccessType",
  objectType: TSType,
  indexType: TSType,
};

export type TSMappedType = {
  ...BaseNode,
  type: "TSMappedType",
  typeParameter: TSTypeParameter,
  typeAnnotation: TSType | null,
  nameType: TSType | null,
  optional: boolean | null,
  readonly: boolean | null,
};

export type TSLiteralType = {
  ...BaseNode,
  type: "TSLiteralType",
  literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral,
};

export type TSExpressionWithTypeArguments = {
  ...BaseNode,
  type: "TSExpressionWithTypeArguments",
  expression: TSEntityName,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type TSInterfaceDeclaration = {
  ...BaseNode,
  type: "TSInterfaceDeclaration",
  id: Identifier,
  typeParameters: TSTypeParameterDeclaration | null,
  extends: Array<TSExpressionWithTypeArguments> | null,
  body: TSInterfaceBody,
  declare: boolean | null,
};

export type TSInterfaceBody = {
  ...BaseNode,
  type: "TSInterfaceBody",
  body: Array<TSTypeElement>,
};

export type TSTypeAliasDeclaration = {
  ...BaseNode,
  type: "TSTypeAliasDeclaration",
  id: Identifier,
  typeParameters: TSTypeParameterDeclaration | null,
  typeAnnotation: TSType,
  declare: boolean | null,
};

export type TSAsExpression = {
  ...BaseNode,
  type: "TSAsExpression",
  expression: Expression,
  typeAnnotation: TSType,
};

export type TSTypeAssertion = {
  ...BaseNode,
  type: "TSTypeAssertion",
  typeAnnotation: TSType,
  expression: Expression,
};

export type TSEnumDeclaration = {
  ...BaseNode,
  type: "TSEnumDeclaration",
  id: Identifier,
  members: Array<TSEnumMember>,
  const: boolean | null,
  declare: boolean | null,
  initializer: Expression | null,
};

export type TSEnumMember = {
  ...BaseNode,
  type: "TSEnumMember",
  id: Identifier | StringLiteral,
  initializer: Expression | null,
};

export type TSModuleDeclaration = {
  ...BaseNode,
  type: "TSModuleDeclaration",
  id: Identifier | StringLiteral,
  body: TSModuleBlock | TSModuleDeclaration,
  declare: boolean | null,
  global: boolean | null,
};

export type TSModuleBlock = {
  ...BaseNode,
  type: "TSModuleBlock",
  body: Array<Statement>,
};

export type TSImportType = {
  ...BaseNode,
  type: "TSImportType",
  argument: StringLiteral,
  qualifier: TSEntityName | null,
  typeParameters: TSTypeParameterInstantiation | null,
};

export type TSImportEqualsDeclaration = {
  ...BaseNode,
  type: "TSImportEqualsDeclaration",
  id: Identifier,
  moduleReference: TSEntityName | TSExternalModuleReference,
  isExport: boolean,
};

export type TSExternalModuleReference = {
  ...BaseNode,
  type: "TSExternalModuleReference",
  expression: StringLiteral,
};

export type TSNonNullExpression = {
  ...BaseNode,
  type: "TSNonNullExpression",
  expression: Expression,
};

export type TSExportAssignment = {
  ...BaseNode,
  type: "TSExportAssignment",
  expression: Expression,
};

export type TSNamespaceExportDeclaration = {
  ...BaseNode,
  type: "TSNamespaceExportDeclaration",
  id: Identifier,
};

export type TSTypeAnnotation = {
  ...BaseNode,
  type: "TSTypeAnnotation",
  typeAnnotation: TSType,
};

export type TSTypeParameterInstantiation = {
  ...BaseNode,
  type: "TSTypeParameterInstantiation",
  params: Array<TSType>,
};

export type TSTypeParameterDeclaration = {
  ...BaseNode,
  type: "TSTypeParameterDeclaration",
  params: Array<TSTypeParameter>,
};

export type TSTypeParameter = {
  ...BaseNode,
  type: "TSTypeParameter",
  constraint: TSType | null,
  default: TSType | null,
  name: string,
};

/**
 * @deprecated Use `NumericLiteral`
 */
export type NumberLiteral = NumericLiteral;

/**
 * @deprecated Use `RegExpLiteral`
 */
export type RegexLiteral = RegExpLiteral;

/**
 * @deprecated Use `RestElement`
 */
export type RestProperty = RestElement;

/**
 * @deprecated Use `SpreadElement`
 */
export type SpreadProperty = SpreadElement;

export type Expression =
  | ArrayExpression
  | AssignmentExpression
  | BinaryExpression
  | CallExpression
  | ConditionalExpression
  | FunctionExpression
  | Identifier
  | StringLiteral
  | NumericLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | LogicalExpression
  | MemberExpression
  | NewExpression
  | ObjectExpression
  | SequenceExpression
  | ParenthesizedExpression
  | ThisExpression
  | UnaryExpression
  | UpdateExpression
  | ArrowFunctionExpression
  | ClassExpression
  | MetaProperty
  | Super
  | TaggedTemplateExpression
  | TemplateLiteral
  | YieldExpression
  | AwaitExpression
  | Import
  | BigIntLiteral
  | OptionalMemberExpression
  | OptionalCallExpression
  | TypeCastExpression
  | JSXElement
  | JSXFragment
  | BindExpression
  | PipelinePrimaryTopicReference
  | DoExpression
  | RecordExpression
  | TupleExpression
  | DecimalLiteral
  | TSAsExpression
  | TSTypeAssertion
  | TSNonNullExpression;
export type Binary = BinaryExpression | LogicalExpression;
export type Scopable =
  | BlockStatement
  | CatchClause
  | DoWhileStatement
  | ForInStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | Program
  | ObjectMethod
  | SwitchStatement
  | WhileStatement
  | ArrowFunctionExpression
  | ClassExpression
  | ClassDeclaration
  | ForOfStatement
  | ClassMethod
  | ClassPrivateMethod
  | StaticBlock
  | TSModuleBlock;
export type BlockParent =
  | BlockStatement
  | CatchClause
  | DoWhileStatement
  | ForInStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | Program
  | ObjectMethod
  | SwitchStatement
  | WhileStatement
  | ArrowFunctionExpression
  | ForOfStatement
  | ClassMethod
  | ClassPrivateMethod
  | StaticBlock
  | TSModuleBlock;
export type Block = BlockStatement | Program | TSModuleBlock;
export type Statement =
  | BlockStatement
  | BreakStatement
  | ContinueStatement
  | DebuggerStatement
  | DoWhileStatement
  | EmptyStatement
  | ExpressionStatement
  | ForInStatement
  | ForStatement
  | FunctionDeclaration
  | IfStatement
  | LabeledStatement
  | ReturnStatement
  | SwitchStatement
  | ThrowStatement
  | TryStatement
  | VariableDeclaration
  | WhileStatement
  | WithStatement
  | ClassDeclaration
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ForOfStatement
  | ImportDeclaration
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareOpaqueType
  | DeclareVariable
  | DeclareExportDeclaration
  | DeclareExportAllDeclaration
  | InterfaceDeclaration
  | OpaqueType
  | TypeAlias
  | EnumDeclaration
  | TSDeclareFunction
  | TSInterfaceDeclaration
  | TSTypeAliasDeclaration
  | TSEnumDeclaration
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExportAssignment
  | TSNamespaceExportDeclaration;
export type Terminatorless =
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
  | YieldExpression
  | AwaitExpression;
export type CompletionStatement =
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement;
export type Conditional = ConditionalExpression | IfStatement;
export type Loop =
  | DoWhileStatement
  | ForInStatement
  | ForStatement
  | WhileStatement
  | ForOfStatement;
export type While = DoWhileStatement | WhileStatement;
export type ExpressionWrapper =
  | ExpressionStatement
  | ParenthesizedExpression
  | TypeCastExpression;
export type For = ForInStatement | ForStatement | ForOfStatement;
export type ForXStatement = ForInStatement | ForOfStatement;
export type Fun =
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | ArrowFunctionExpression
  | ClassMethod
  | ClassPrivateMethod;
export type FunctionParent =
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | ArrowFunctionExpression
  | ClassMethod
  | ClassPrivateMethod;
export type Pureish =
  | FunctionDeclaration
  | FunctionExpression
  | StringLiteral
  | NumericLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ArrowFunctionExpression
  | BigIntLiteral
  | DecimalLiteral;
export type Declaration =
  | FunctionDeclaration
  | VariableDeclaration
  | ClassDeclaration
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ImportDeclaration
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareOpaqueType
  | DeclareVariable
  | DeclareExportDeclaration
  | DeclareExportAllDeclaration
  | InterfaceDeclaration
  | OpaqueType
  | TypeAlias
  | EnumDeclaration
  | TSDeclareFunction
  | TSInterfaceDeclaration
  | TSTypeAliasDeclaration
  | TSEnumDeclaration
  | TSModuleDeclaration;
export type PatternLike =
  | Identifier
  | RestElement
  | AssignmentPattern
  | ArrayPattern
  | ObjectPattern;
export type LVal =
  | Identifier
  | MemberExpression
  | RestElement
  | AssignmentPattern
  | ArrayPattern
  | ObjectPattern
  | TSParameterProperty;
export type TSEntityName = Identifier | TSQualifiedName;
export type Literal =
  | StringLiteral
  | NumericLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | TemplateLiteral
  | BigIntLiteral
  | DecimalLiteral;
export type Immutable =
  | StringLiteral
  | NumericLiteral
  | NullLiteral
  | BooleanLiteral
  | BigIntLiteral
  | JSXAttribute
  | JSXClosingElement
  | JSXElement
  | JSXExpressionContainer
  | JSXSpreadChild
  | JSXOpeningElement
  | JSXText
  | JSXFragment
  | JSXOpeningFragment
  | JSXClosingFragment
  | DecimalLiteral;
export type UserWhitespacable =
  | ObjectMethod
  | ObjectProperty
  | ObjectTypeInternalSlot
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty;
export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
export type ObjectMember = ObjectMethod | ObjectProperty;
export type Property = ObjectProperty | ClassProperty | ClassPrivateProperty;
export type UnaryLike = UnaryExpression | SpreadElement;
export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;
export type Klass = ClassExpression | ClassDeclaration;
export type ModuleDeclaration =
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ImportDeclaration;
export type ExportDeclaration =
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration;
export type ModuleSpecifier =
  | ExportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier;
export type Flow =
  | AnyTypeAnnotation
  | ArrayTypeAnnotation
  | BooleanTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | NullLiteralTypeAnnotation
  | ClassImplements
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareOpaqueType
  | DeclareVariable
  | DeclareExportDeclaration
  | DeclareExportAllDeclaration
  | DeclaredPredicate
  | ExistsTypeAnnotation
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | InferredPredicate
  | InterfaceExtends
  | InterfaceDeclaration
  | InterfaceTypeAnnotation
  | IntersectionTypeAnnotation
  | MixedTypeAnnotation
  | EmptyTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | ObjectTypeAnnotation
  | ObjectTypeInternalSlot
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | OpaqueType
  | QualifiedTypeIdentifier
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | SymbolTypeAnnotation
  | ThisTypeAnnotation
  | TupleTypeAnnotation
  | TypeofTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | UnionTypeAnnotation
  | Variance
  | VoidTypeAnnotation;
export type FlowType =
  | AnyTypeAnnotation
  | ArrayTypeAnnotation
  | BooleanTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | NullLiteralTypeAnnotation
  | ExistsTypeAnnotation
  | FunctionTypeAnnotation
  | GenericTypeAnnotation
  | InterfaceTypeAnnotation
  | IntersectionTypeAnnotation
  | MixedTypeAnnotation
  | EmptyTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | ObjectTypeAnnotation
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | SymbolTypeAnnotation
  | ThisTypeAnnotation
  | TupleTypeAnnotation
  | TypeofTypeAnnotation
  | UnionTypeAnnotation
  | VoidTypeAnnotation;
export type FlowBaseAnnotation =
  | AnyTypeAnnotation
  | BooleanTypeAnnotation
  | NullLiteralTypeAnnotation
  | MixedTypeAnnotation
  | EmptyTypeAnnotation
  | NumberTypeAnnotation
  | StringTypeAnnotation
  | SymbolTypeAnnotation
  | ThisTypeAnnotation
  | VoidTypeAnnotation;
export type FlowDeclaration =
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareOpaqueType
  | DeclareVariable
  | DeclareExportDeclaration
  | DeclareExportAllDeclaration
  | InterfaceDeclaration
  | OpaqueType
  | TypeAlias;
export type FlowPredicate = DeclaredPredicate | InferredPredicate;
export type EnumBody =
  | EnumBooleanBody
  | EnumNumberBody
  | EnumStringBody
  | EnumSymbolBody;
export type EnumMember =
  | EnumBooleanMember
  | EnumNumberMember
  | EnumStringMember
  | EnumDefaultedMember;
export type JSX =
  | JSXAttribute
  | JSXClosingElement
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXSpreadChild
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXSpreadAttribute
  | JSXText
  | JSXFragment
  | JSXOpeningFragment
  | JSXClosingFragment;
export type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;
export type TSTypeElement =
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSPropertySignature
  | TSMethodSignature
  | TSIndexSignature;
export type TSType =
  | TSAnyKeyword
  | TSBooleanKeyword
  | TSBigIntKeyword
  | TSIntrinsicKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSFunctionType
  | TSConstructorType
  | TSTypeReference
  | TSTypePredicate
  | TSTypeQuery
  | TSTypeLiteral
  | TSArrayType
  | TSTupleType
  | TSOptionalType
  | TSRestType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSParenthesizedType
  | TSTypeOperator
  | TSIndexedAccessType
  | TSMappedType
  | TSLiteralType
  | TSExpressionWithTypeArguments
  | TSImportType;
export type TSBaseType =
  | TSAnyKeyword
  | TSBooleanKeyword
  | TSBigIntKeyword
  | TSIntrinsicKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSLiteralType;

export type Aliases = {
  Expression: Expression,
  Binary: Binary,
  Scopable: Scopable,
  BlockParent: BlockParent,
  Block: Block,
  Statement: Statement,
  Terminatorless: Terminatorless,
  CompletionStatement: CompletionStatement,
  Conditional: Conditional,
  Loop: Loop,
  While: While,
  ExpressionWrapper: ExpressionWrapper,
  For: For,
  ForXStatement: ForXStatement,
  Function: Fun,
  FunctionParent: FunctionParent,
  Pureish: Pureish,
  Declaration: Declaration,
  PatternLike: PatternLike,
  LVal: LVal,
  TSEntityName: TSEntityName,
  Literal: Literal,
  Immutable: Immutable,
  UserWhitespacable: UserWhitespacable,
  Method: Method,
  ObjectMember: ObjectMember,
  Property: Property,
  UnaryLike: UnaryLike,
  Pattern: Pattern,
  Class: Klass,
  ModuleDeclaration: ModuleDeclaration,
  ExportDeclaration: ExportDeclaration,
  ModuleSpecifier: ModuleSpecifier,
  Flow: Flow,
  FlowType: FlowType,
  FlowBaseAnnotation: FlowBaseAnnotation,
  FlowDeclaration: FlowDeclaration,
  FlowPredicate: FlowPredicate,
  EnumBody: EnumBody,
  EnumMember: EnumMember,
  JSX: JSX,
  Private: Private,
  TSTypeElement: TSTypeElement,
  TSType: TSType,
  TSBaseType: TSBaseType,
};
