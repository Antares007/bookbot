// args ""
id := true a

pstr :=
	{ string:[ match, input ], function:[ o ] } 
		match.length > input.length
		o 'error'
		true
		loop :=
			{number:[ i ]} 
				i === match.length
				o 'tok' i
				match[i] !== input[i]
				o 'error'
				i < match.length 
				loop (i + 1)
		loop 0 

const pnot
	{string: input, function: [pnar, o]}
	pnar <=
		{number: len} && len < 0
			apply o a
		{number: len}
			call o - 0 len
	<= 5 6 8
const por
	{function [lnar rnar]}
			{function o}
				call lnar
					&& {number: len} < len 0
						call rnar o
					{number _}
						apply o a
pand :=
	{ string: input, function: [o, ...nars] }
	loop :=
		{number: i}
			i < nars.length
			loop (i + 1)
			true
			//
	loop 0

pmany :=
	{ function: [pnar, o] }
	len := 0
	p :=
		{string:['tok'], number:[l]}
		len = len + l
		pnar p
		true 
		o 'tok' len
	pnar p

const Tab
	{string input function o}
		call
			&& > input.length 0
			   === 0x09 input.charCodeAt(0)
				call o 1
			&& > input.length 1
			&& === 0x20 input.charCodeAt(0)
			   === 0x09 input.charCodeAt(1)
				call o 2
			&& > input.length 2
			&& === 0x20 input.charCodeAt(0)
			&& === 0x20 input.charCodeAt(1)
			   === 0x09 input.charCodeAt(2)
				call o 3
			&& > input.length 3
			&& === 0x20 input.charCodeAt(0)
			&& === 0x20 input.charCodeAt(1)
			&& === 0x20 input.charCodeAt(2)
			   === 0x09 input.charCodeAt(3)
				call o 4
			else
				call o -1
const Eol
	{ string input function o }
		call
			&& >   input.length 0
			   === 0x0a input.charCodeAt(0) 
				call o 1
			else
				call o -1
const Eof
	{ string input function o }
		call
			=== input.length 0
				call o 0
			else
				call o -1
const Line
	{number d}
			{ string input function o }
				call
					=== input.length 0
						call o 0
					else
						call o -1





Line[i] const
	| Tab0 ... Tabi pnot(Tab) pnot(Eol) Eol
	| 
	| Eol

Bolk[i] const
	| Line[i]*
	| Bolk[i+1]
	| Eol



1
2
	1
	2
		1
		2
		3
	3
		1
	4
	5
3



Kind = ("const" | "var") Id 

const g
	=== 'function' typeof a
	//
const a_person_t
	{ string: ['person' name lastname] }
		a
	{ string: ['person' name lastname] object a_person_t }
		a
	___
		null

const ramiz ('person' 'ramiz' 'bolkvadze')
const otar ('person' 'otar' 'bolkvadze' ramiz)
const archil ('person' 'archil' 'bolkvadze' otar)


const a_string_t
	=== 'string' typeof a a    // a_string_t ''
	{ string a }          a    // a_string_t ('')
	___ null

const p
	a_string_t  a
	a_element_t a

const a_element_t
	{ string ['element' tag key] function f(p) } a
	{ string ['element' tag]     function f(p) } a
	___											 null

const pith
	instanceof a HTMLElement
		const elm          a
		const childNodes   elm.childNodes
		const childPiths   []
		var   childs_count 0
		const o
			=== 'string' typeof a
				//
			=== 'undefined' typeof a
				//
			{ function f(elm) }
				//
			{ string ['element', tag, key] function f(o) }
				//

		o
const c
	=== 'number' typeof a
		const nar
			
			
		nar
const o pith document.createElement('div')
o 'hello'
o 'element' 'div' ''
	o 'hello'
	o 'element' 'div' ''
	
	




= s.sum
	 
= s.pith
	=== a.object instanceof HTMLElement
	const elm		   a.object
	var   childs_count 0
	const childNodes   elm.childNodes
	const childPiths   []
	s.parent.pith
	return
		= s.test i.string

if lexp else  exp  exp
else exp
else
	exp_bolk
pith document.createElement('div')

const pith
	=== a.object.constructor.name HTMLElement
	const elm          a.object
	const childNodes   elm.childNodes
	const childPiths   []
	var   childs_count 0
	return
		=== i void 0
			let l childNodes.length
			for > l childs_count l++
				elm.removeChild childNodes[childs_count]
		=== i.string 'get'
		  i.function elm
		>   a.string.length 0
			const text = a.string
			const loop
				&& iof    a.object[0] Node
				   || iof a.object[1] Node
				      ==  a.object[1] null
				 
					//
					//
				iof a.object Node
					loop a.object a.object.nextSibling 
					//
					//
				== a.object null
					//

				const i = a.number[0]
				var index = a.number[1]
				var l = a.number[2]
				< i l
					var aa
						=== a.boolean true
							< index i
								elm.insertBefore elm.childNodes[a.number] elm.childNodes[index]
								childPiths.splice index 0 ...childPiths.splice(i, 1)
						___
							loop + i 1 l elm
					aa && === a.object.nodeType 3
						  === a.string a.object.textContent
			loop childNodes[childNodes++]

			for < i l i++
		  	    if
		  	        &&  === childNodes[i].nodeType 3
		  	            &&  === childNodes[i].nodeType 3
		  	                === i.string childNodes[i].textContent
		  	        if < index i
		  	            elm.insertBefore childNodes[i] childNodes[index]
		  	            childPiths.splice index 0 ...childPiths.splice(i, 1)
		  	    return
		  	elm.insertBefore document.createTextNode(i.string) childNodes[index]
			childPiths.splice index 0 null
		>   i.string.length 0
		  //pith 'div'
		  //  o 'hello world'
		  //  o 'div'
		  //    o 'hi'
		  var nar = i.function
		>   i.string[0].length 0
		  let n
		  let ob
		  var index childs_count++
		  var tag   i.string[0].toUpperCase()
		  var nar   i.function
		  var key   i.string[1]
